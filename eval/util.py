from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional, Dict, Any

import os
import json
import subprocess
import time
import tempfile
import shlex

solvers = None

def get_solvers() -> str:
    global solvers
    if not solvers:
        with open('solvers.json', 'rt') as f:
            try:
                solvers = { k: os.path.expandvars(v) for k, v in json.load(f).items() }
                for k, v in solvers.items():
                    if not Path(v).is_file():
                        raise Exception(f'Solver {k} path {v} is not a file')
                print(solvers)
            except FileNotFoundError:
                raise Exception('solvers.json not found')
    return solvers

@dataclass(frozen=True)
class Run:
    iteration: int
    timeout: Optional[int]

    def __repr__(self):
        return self.get_id()

    def get_id(self):
        """Unique ID for this run (without iteration and timeout)."""
        return f'timeout:{self.timeout}_{self.iteration:04d}'

    def read_stats(self, stats_file: Path):
        """Read the stats file generated by ran command."""
        raise NotImplementedError()

    def get_cmd(self, stats_file: Path):
        """Run the benchmark command, writing stats to stats_file."""
        raise NotImplementedError()

    def get_results_filename(self, output_dir: Path):
        return output_dir / Path(f'{self.get_id()}.json')

    def read_result(self, output_dir: Path):
        results_file = self.get_results_filename(output_dir)
        assert results_file.exists()
        with open(results_file, 'rt') as f:
            return json.load(f)

    def run(self, output_dir: Path):
        ns = 1_000_000_000
        result_file = self.get_results_filename(output_dir)
        with tempfile.NamedTemporaryFile() as f:
            cmd = self.get_cmd(f.name)
            print(cmd)
            args = shlex.split(cmd)
            try:
                start = time.perf_counter_ns()
                p = subprocess.run(args, timeout=self.timeout, check=True,
                                   capture_output=True, text=True)
                duration = (time.perf_counter_ns() - start)
                stats = {
                    'timeout': False,
                    'wall_time': duration,
                    'output': p.stdout,
                    'stats': self.read_stats(Path(f.name)),
                }
                print(f'success: {duration / ns:.3f}s')
            except subprocess.TimeoutExpired as e:
                stats = { 'timeout': True, 'wall_time': self.timeout * ns }
                print(f'timeout after {self.timeout}s')
            except subprocess.CalledProcessError as e:
                stats = None
                print(f'Error code {e.returncode} in {cmd}: {e.stderr}', file=os.sys.stderr)
        if stats:
            assert output_dir.exists() and output_dir.is_dir()
            with open(result_file, 'wt') as f:
                json.dump(stats, f, indent=4)

    def dispatch(self, pool, output_dir: Path):
        pool.apply_async(self.run, (output_dir, ))

@dataclass(frozen=True)
class SynthRun(Run):
    set: str
    bench: str
    synth: str
    solver: Optional[str] = 'external-z3'
    run_opts: Dict[str, Any] = field(default_factory=dict)
    set_opts: Dict[str, Any] = field(default_factory=dict)
    syn_opts: Dict[str, Any] = field(default_factory=dict)

    def prepare_opts(opts, prefix=None):
        prefix = f'{prefix}.' if prefix else ''
        for k, v in opts.items():
            if isinstance(v, bool):
                yield f'--{prefix}' + ('' if v else 'no-') + k
            else:
                yield f'--{prefix}{k} {v}'

    def get_args(self):
        global solvers
        run_opts = ' '.join(SynthRun.prepare_opts(self.run_opts))
        set_opts = ' '.join(SynthRun.prepare_opts(self.set_opts, prefix='set'))
        syn_opts = ' '.join(SynthRun.prepare_opts(self.syn_opts, prefix='synth'))
        if path := get_solvers()[self.solver]:
            solver_path = f'--synth.solver.path {path}'
        else:
            solver_path = ''
        return f'--tests {self.bench} {run_opts} set:{self.set} {set_opts} synth:{self.synth} {syn_opts} synth.solver:{self.solver} {solver_path}'

    def get_id(self):
        res = f'{self.set}_{self.bench}_{self.synth}_{self.solver}'
        for d in [self.run_opts, self.set_opts, self.syn_opts]:
            for k, v in d.items():
                res += f'_{k}:{v}'
        res += '_' + super().get_id()
        assert ' ' not in res and '/' not in res
        return res

    def read_stats(self, stats_file: Path):
        with open(stats_file, 'rt') as f:
            return json.load(f)

    def get_cmd(self, stats_file: Path):
        args = self.get_args()
        return f'python benchmark.py run --stats {stats_file} {args}'

class Experiment:
    def get_name(self):
        return self.__class__.__name__

    def get_output_filename(self, output_dir: Path, suffix=''):
        return output_dir / Path(f'{self.get_name()}{suffix}.txt')

    def map(self, f):
        def _map(exp, f):
            match exp:
                case dict():
                    return { k: _map(v, f) for k, v in exp.items() }
                case list():
                    return [ _map(e, f) for e in exp ]
                case Run():
                    return f(exp)
        return _map(self.exp, f)

    def runs(self):
        def _iter(exp):
            match exp:
                case dict():
                    for v in exp.values():
                       yield from _iter(v)
                case list():
                    for e in exp:
                        yield from _iter(e)
                case Run():
                    yield exp
        yield from _iter(self.exp)

    def to_run(self, output_dir: Path):
        for run in self.runs():
            if not run.get_results_filename(output_dir).exists():
                yield run

class ComparisonExperiment(Experiment):
    def evaluate(self, stats_dir: Path, output_dir: Path, width=16):
        output_file = self.get_output_filename(output_dir)
        with open(output_file, 'wt') as f:
            get_wall_time = lambda t: t['wall_time'] / 1_000_000_000
            res = self.map(lambda r: r.read_result(stats_dir))
            heads = [f'{'bench':{width}}'] + list(next(iter(res.values())).keys())
            print(' '.join(f'{h:>{width}}' for h in heads), file=f)
            for bench, competitors in res.items():
                times = [ sum(map(get_wall_time, trials)) / len(trials) for trials in competitors.values() ]
                times = ' '.join(f'{t:>{width}.5f}' for t in times)
                print(f'{bench:{width}} {times}', file=f)